# Урок 27
Для начала работы скопируйте репозиторий на локальную машину:
c помощью команды в терминале

`https://github.com/skypro-008/lesson27-and-tests.git`

Откройте с клонированный репозиторий в PyCharm.

### Cоздайте виртуальное окружение:

#### Простой вариант:
Pycharm может предложить вам сделать это после того, как вы откроете папку с проектом.
В этом случае после открытия папки с проектом в PyCharm
Появляется всплывающее окно, Creating virtuan envrironment c тремя полями.
В первом поле выбираем размещение папки с вирутальным окружением, как правило это папка venv
в корне проекта
Во втором поле выбираем устанавливаемый интерпритатор по умолчанию (можно оставить без изменений)
В 3 поле выбираем список зависимостей (должен быть выбран фаил requirements.txt, находящийся в корне папки проекта)

#### Если этого не произошло, тогда следует выполнить следующие действия вручную:
#### Установка виртуального окружения:
1. Во вкладке File выберите пункт Settings
2. В открывшемся окне, с левой стороны найдите вкладку с именем
вашего репозитория (Project: lesson27-and-tests)
3. В выбранной вкладке откройте настройку Python Interpreter
4. В открывшейся настройке кликните на значек ⚙ (шестеренки) 
расположенный сверху справа и выберите опцию Add
5. В открывшемся окне слева выберите Virtualenv Environment, 
а справа выберите New Environment и нажмите ОК

#### Установка зависимостей:
Для этого можно воспользоваться графическим интерфейсом PyCharm,
который вам предложит сделать это как только вы откроете файл с заданием.

Или же вы можете сделать это вручную, выполнив следующую команду в терминале:
`pip install -r requirements.txt`

#### Настройка виртуального окружения завершена!
### Подготовка проекта django
После того, как Вы установили все зависимости, необходимо подготовить django к работе:
для этого нам потребуется:

1. Иметь возможность запуска на локальной машине docker-контейнера 
(необходимо для запуска контейнера с базы данных):
- переходим в каталог postgres_l27 и выполняем команду docker-compose up.

2. Выполнить необходимые команды для подготовки базы данных к работе:
Текущий проект уже содержит настроенную базу данных, но пока еще она 
пустая, не содержит таблиц, а всё её наполнение
находится в фикстурах (в django - файлы в формате json содержащие данные для наполнения БД).

Для начала нужно создать необходимые таблицы в базе данных с помощью команды:
python3 manage.py migrate (находясь в папке my_project_part_1)
а затем выполнить команду python3 manage.py loadall из этой же директории
   (для загрузки всех объектов в базу данных).
После того как все подготовительные мероприятия выполнены - можно приступать к работе.

Первое, что необходимо сделать - изучите представленный проект.
Он имеет три приложения - tech_support, courses и cars
каждое приложение имеет свой неймспейс, который можно посмотреть,
открыв файл urls.py главного приложение 'my_project'.
Обращаясь на адрес tech_support - мы работаем с приложением tech_support
Обращаясь на адрес /courses/ - с приложением courses
и обращаясь на адрес /cars/ - соответственно работаем с приложением cars.
*Обратите внимание, что часть адресов, представленных в заданиях ниже уже реализованы.
и здесь Вам требуется только дополнить их соответствующим образом.*


### Порядок выполнения заданий
Так как django содержит свою структуру и имеет значительное количество файлов. 
Мы разместим здесь указатель в какой последовательности следует выполнять задания.

## Часть 1. my_project_part_1

### Задание tech_support
Перейдите в файл tech_support/views.py и напишите view-функцию 
которая возвращает все объекты содержащие обращения в тех-поддержку в формате json.

### Задание courses
Перейдите в файл courses/urls.py и напишите эндпоинт, при обращение на который
срабатывает view-функция courses (Которая уже реализована).

### Задание new_courses
Перейдите в файл courses/views.py и напишите view-функцию, которая при
GET-запросе на адрес /courses/ вернет все курсы в формате json.

### Задание find_by_name
Перейдите в файл courses/views.py и напишите view-функцию, которая при
GET-запросе на адрес /courses/{slug} вернет объект курса с указанным слаг в формате json
а также сделайте дополнительные правки файла urls.py django-приложения courses.

### Задание who's_author
Перейдите в файл courses/views.py и напишите view-функцию, которая при
GET-запросе на адрес /courses/?author=author_name вернет все объекты курса с автором author_name в формате json.
а также сделайте дополнительные правки файла urls.py django-приложения courses.

### Задание car_card
Перейдите в файл cars/views.py и напишите view-функцию, которая при
GET-запросе на адрес /cars/{id} вернет один объект с соответствующим id в формате json.
а также сделайте дополнительные правки файла urls.py django-приложения courses.

### Задание car_search
Перейдите в файл cars/views.py и напишите view-функцию, которая при
GET-запросе на адрес /cars/?search=brand вернет список объектов соответствующего бренда в формате json.
Ответ должен содержать только поля id, name, brand, status
а также сделайте дополнительные правки файла urls.py django-приложения courses.

Переходите к запуску тестов только после выполнения всех заданий.
Для запуска тестов воспользуйтесь командой python3 manage.py test (находясь в папке my_project_part_1)
Также вы можете проверить правильность работы приложения - для этого используйте команду
python3 manage.py test <app>


## Часть 2. my_project_part_2
Перед тем как приступать ко второй части проекта, не забудьте выполнить миграции
с помощью команды python3 manage.py migrate

### Задание fbv_to_cbv
Перейдите в файл cars/views.py и перепишите view-функцию 'cars' на class based view 'CarView'
a также отредактируйте соответствующим образом файл cars/urls.py

### Задание shops
Перейдите в файл shops/models.py и реализуйте класс 
модели в соответствии со спецификацией, представленной в файле.

### Задание same_classes
Внимательно изучите приложение same_classes
В особенности модель Feedback, и CBV, которые к ней относятся (файл /some_classes/views.py).
Напишите аналогичные CBV для модели destination, а также настройте urls для данных CBV.

Требования:
поля to_name и flag служебные и не должны нигде показываться,
в полном списке отображаются только поля id и name.
Полный список моделей должен возвращаться при GET запросе на адрес /classes/destination/
Новый объект в БД должен создаваться при POST запросе на адрес /classes/destination/,
при этом необходимые названия полей, передаваемые при POST запросе должны соответсвовать
названиям полей модели.
Получить объект можно при GET запросе на адрес /classes/destination/{id}/
Ответ на запрос единичного объекта должен содержать все поля модели.

### Задание destination_point
Добавьте в файл /some_classes/views.py еще 2 CBV.
DestinationListView и DestinationDetailView, 
на основе изученных ранее 
Generic Classes.

Требования прежние, за исключением urls:
поля to_name и flag служебные и не должны нигде показываться,
в полном списке отображаются только поля id и name.
Полный список моделей должен возвращаться при GET запросе на адрес /classes/gen-destination/
Новый объект в БД должен создаваться при POST запросе на адрес /classes/gen-destination/,
при этом необходимые названия полей, передаваемые при POST запросе должны соответсвовать
названиям полей модели.
Получить объект можно при GET запросе на адрес /classes/gen-destination/{id}/
Ответ на запрос единичного объекта должен содержать все поля модели.

Переходите к запуску тестов только после выполнения всех заданий.
Для запуска тестов воспользуйтесь командой python3 manage.py test (находясь в папке my_project_part_1)
Также вы можете проверить правильность работы приложения - для этого используйте команду
python3 manage.py test <app>

